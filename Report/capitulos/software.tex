\chapter{Software involucrado en el proyecto} \label{chap:SW}

    En este capítulo se hace una descripción detallada del software involucrado en este proyecto, tanto el desarrollado para el mismo como el heredado de fuentes externas.

    Para el desarrollo y test del software se ha utilizado el editor Atom ampliando su funcionalidad con el paquete Platformio, que expande las capacidades del editor base para permitir trabajar con diferentes placas, entre ellas las de la gama de Arduino.

    La elección de esta herramienta conlleva un formato en el arbol de directorios en los que se separa el código determinado. Concretamente queda de la siguiente manera:

    \begin{table}[tb]
    \caption{Arbol de directorios}
    \label{SW:tab:arbol_directorios}
    \begin{center}
    \begin{tabular}{|c|}
        \hline
        -- Sw
         |-- lib
         |  |-- cytron_g15_servo
         |  |-- debug
         |  |-- joint_rha
         |  |-- servo_rha
         |  |-- readme.txt
         |-- src
         |  |-- main.cpp
         |-- test
         |  |-- test_cytrong_g15_servo
         |  |-- test_servo_mock
         |  |-- test_servo_real
         |-- platformio.ini
         __
         |-- code_analysis
         |-- makeAnalysis.sh
        \hline
    \end{tabular}
    \end{center}
    \end{table}

    En los siguientes apartados se hará un análisis detallado del contenido de estos directorios.
\section{Librerías (directorio lib):} \label{sec:SW:lib}
    \subsection{cytron_g15_servo} \label{subsec:SW:lib:cytron}
        La librería cytron_g15_servo gestiona la comunicación a bajo nivel con los servos Cytron G15 Cube así como funcionalidades básicas de los mismos.

        Esta librería es un desarrollo derivado de la librería para Arduino oficial que aporta Cytron Technologies: Cytron_G15Shield (¡ENLACE! https://github.com/CytronTechnologies/Cytron-G15Shield).

        Ha sido modificada para adaptarla a las necesidades de este proyecto. Algunos cambios importantes son:

        \begin{itemize}
            \item Modificación del objeto base Cytron_G15Shield a Cytron_G15_Servo. En la librería original se trabaja definiendo un objeto de la clase Cytron_G15Shield que gestiona la comunicación de la placa con los servos. En este caso múltiples servos recurren a este mismo objeto para invocar las diferentes funcionalidades, indicando el ID del servo sobre el que se quiere actuar. En el caso del objeto Cytron_G15_Servo lo que se define es un objeto asociado a cada servo, de esta forma no es necesario especificar el ID en cada llamada a la función (se indica cuando se construye el objeto). En vez de trabajar en base a un objeto que gestiona un puerto de comunicación serie se trabaja en base a un objeto que gestiona un servo.
            \item Varios métodos de la librería original han sido modificados para generalizar su funcinalidad. Por ejemplo:
                Los servos permiten diferentes modos de trabajo a la hora de enviar comandos respecto a su ejecución. La primera pasa por la ejecución de los mismos en el momento de la recepción, mientras que en el segundo caso se puede separar la recepción del comando de su posterior ejecución, que se activará cuando se desee.

                En el caso de la librería original por defecto los comandos se envían para su ejecución inmediata. Esto ha sido modificado de forma que al invocar ciertas funciones podremos elegir la opción deseada.
            \item Ya las anteriores modificaciones eran necesarias, además, se ha adaptado la sintaxis original de la librería a las reglas de codificación establecidas para este proyecto.
        \end{itemize}

    \subsection{debug} \label{subsec:SW:lib:debug}
        Dentro de este directorio se encuentra el fichero debug.h donde se han definido macros para debug de los diferentes espacios. A continuación se muestra un ejemplo para el debug de la clase servo_rha (Ver apartado \ref{subsec:SW:lib:servo_rha}).

        \lstset{language=C, breaklines=true, basicstyle=\footnotesize}
        %Introducir label y captio
        \begin{lstlisting}[frame=single]
            #ifdef DEBUG_SERVO_RHA
                #define DebugSerialSRHALn(a) {  Serial.print("[DC]  ServoRHA::"); Serial.println(a); }
                #define DebugSerialSRHALn2(a, b) {  Serial.print("[DC]  ServoRHA::"); Serial.print(a); Serial.println(b); }
                #define DebugSerialSRHALn4(a, b, c, d) {  Serial.print("[DC]  ServoRHA::"); Serial.print(a); Serial.print(b); Serial.print(c); Serial.println(d); }
            #else
                #define DebugSerialSRHALn(a)
                #define DebugSerialSRHALn2(a, b)
                #define DebugSerialSRHALn4(a, b, c, d)
            #endif
        \end{lstlisting}

        Como se puede apreciar estas macros utilizan la comunicación serial de Arduino, concretamente la función print y println de la librería Serial para mostrar los mensajes en un formato determinado. Además se definen de tal forma que se pueden activar o desactivar (en este mismo fichero debug.h) de forma que se enviarán o no los mensajes de debug.

        Para activarlos bastará con descomentar la línea correspondiente:

        \lstset{language=C, breaklines=true, basicstyle=\footnotesize}
        %Introducir label y captio
        \begin{lstlisting}[frame=single]
            // #define DEBUG_SERVO_RHA
            // #define DEBUG_TEST_SERVO_RHA_MOCK
            #define DEBUG_TEST_SERVO_RHA_REAL
            // #define DEBUG_CYTRON_G15_SERVO
            // #define DEBUG_TEST_CYTRON_G15_SERVO
        \end{lstlisting}

    \subsection{joint_rha} \label{subsec:SW:lib:joint_rha}
    \subsection{servo_rha} \label{subsec:SW:lib:servo_rha}

\section{SRC. Fichero de código principal:}

\section{Tests y verificación:}
    Como parte del proyecto se han desarrollado una serie de test para verificar el correcto funcionamiento de las diferentes librerías.

    Para el desarrollo y ejecución de dichos test se ha utilizado la funcionalidad de test que viene integrada en Platformio. Esta, permite definir una serie de test que pueden ser ejecutados en la propia placa. De esta forma se puede automatizar el proceso de test.

    Una completa definición de test (desde test unitarios hasta test de integración) permite controlar de forma continuada el correcto funcionamiento del sistema frente a modificaciones en el código. De forma genérica estos test se dividen en:

    \begin{itemize}
        \item test_cytrong_g15_servo -
        \item test_servo_mock
        \item test_servo_real
    \end{itemize}

    El el directorio SW/test se encuentran definidos los diferentes test que se realizan. Cada fichero de test, destinado a testear de forma parcial o completa una libreria, tiene diferentes test definidos en formato de función para los diferentes métodos contenidos en la librería.

    Para testear un método o grupo de métodos se define una función de test en la que se define la ejecución que se va a realizar, con las entradas predefinidas de forma que se puede comprobar como ciertas salidas o parámetros internos satisfacen las necesidades impuestas. Para la definición de estas condiciones así como de los test se sigue el formato propuesto desde Platformio Test y la API que adjuntan.


\section{Gestión de la complejidad y mantenibilidad:}
